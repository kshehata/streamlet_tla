----------------------------- MODULE Blocks -----------------------------

EXTENDS Integers, FiniteSets

CONSTANT NewView, Prepare, PreCommit, Commit, Decide, Replicas, Null, QCThresh

ASSUME QCThresh \in Nat

(***************************************************************************)
(* Block Tree Types *)
(***************************************************************************)

BlockType == [ 
    \* Unique identifier for each block.
    id : Nat,
    \* Parents are referenced by their id as well.
    parent : Nat
]

GenesisBlock == [ id |-> 0, parent |-> 0 ]

CreateBlock(id, parent) == [ id |-> id, parent |-> parent.id ]

\* True if b1 extends b2 directly (i.e. with no other blocks in between)
DirectlyExtends(b1, b2) == b1.parent = b2.id

RECURSIVE NoLoopsImpl(_, _, _)
NoLoopsImpl(b, allBlocks, blocksSeen) ==
    \A c \in allBlocks : 
        ( c # b /\ DirectlyExtends(c, b) ) =>
            /\ c \notin blocksSeen
            /\ NoLoopsImpl(c, allBlocks, blocksSeen \union {b})

NoLoops(S) == \A b \in S : NoLoopsImpl(b, S, {})

RECURSIVE BlockExtends(_, _, _)
BlockExtends(b1, b2, blocks) ==
    \/ DirectlyExtends(b1, b2)
    \/ (\E b3 \in blocks : /\ b3 # b1
                           /\ DirectlyExtends(b1, b3)
                           /\ BlockExtends(b3, b2, blocks))

\* Returns true IFF b1 does not extend b2 and b
BlocksDoNotConflict(b1, b2, blocks) ==
    \/ b1 = b2
    \/ BlockExtends(b1, b2, blocks)
    \/ BlockExtends(b2, b1, blocks)

\* Check that there are no conflicting blocks in S1 or S2
NoConflictsInBlockSets(S1, S2, blocks) ==
    \A b1 \in S1 : \A b2 \in S2 :
        BlocksDoNotConflict(b1, b2, blocks)


(***************************************************************************)
(* Quorum Certificates (QC) *)
(***************************************************************************)

QCType == [
    \* Phase that generated QC
    type : {Prepare, PreCommit, Commit},
    \* View number that generated QC
    viewNum : Nat,
    \* Block for which QC applies
    block : BlockType
    \* No actual signature. Assume that if this gets created, it's valid.
]

GenesisQC(type) == [ type |-> type, viewNum |-> 0, block |-> GenesisBlock ]

\* Votes are just Messages (see below) with votes for a block
CheckVotesForQC(votes) ==
    /\ LET x == CHOOSE v \in votes : TRUE IN
        /\ \A v \in votes : v.type = x.type /\ v.viewNum = x.viewNum
    /\ Cardinality({v.vote : v \in votes}) >= QCThresh
    \* TODO: Check block??
    \* or received ?

\* KMS NOTE: have to filter for blocks that aren't null because of assymetry
\* in how leader sends broadcast and how votes are sent back.
GenerateQC(votes) ==
    LET v == CHOOSE v \in votes : v.block # Null IN
    [ type |-> v.type, viewNum |-> v.viewNum, block |-> v.block ]


(***************************************************************************)
(* Messages *)
(***************************************************************************)

MessageType == [
    \* The phase the message belongs in
    type : {NewView, Prepare, PreCommit, Commit, Decide},
    \* The view number the message belongs to
    viewNum : Nat,
    \* The block under consideration
    block : BlockType \union {Null},
    \* Any justifying QC if applicable
    justify : QCType \union {Null},
    \* Vote represents a signature generated by a replica
    vote : Replicas
]

CreateMessage(type, vn, block, justify, sender) == [
    type |-> type,
    viewNum |-> vn,
    block |-> block,
    justify |-> justify,
    vote |-> sender
]

\* Utility to get the message with a justify QC with max viewNum
\* Used in NewView
MaxJustifyVN(M) == CHOOSE m \in M : \A x \in M :
        m.justify.viewNum >= x.justify.viewNum

=============================================================================
